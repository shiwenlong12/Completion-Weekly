chapter4:地址空间
/*
chapter4与之前相比，难度大了很多，在我们前面的章节当中，我们访问内存的方式都是通过一个物理地址的方式，我们直接给出物理地址，然后计算机会到对应物理地址的地方去访问对应的内存单元，但是到了本章地址空间，我们开启了一个映射机制，也就是说我们给出的是一个虚拟地址，然后虚拟地址会经过一系列硬件机制的映射，把这个虚拟地址转化为一个对应的物理地址。这样的话，我们实际上是使用虚拟地址去访问，通过硬件机制去进行一个地址转化，这个硬件叫MMU，通过这个转化之后，我们的计算机会到对应的物理地址的位置去访问。 
*/


# 实验逻辑和基本设计
## 实验逻辑
/*
1、我们的操作系统可以同时存在多个不同的任务，我们可以把它们称为进程。  
1、页表就是给我们的进程的地址映射做服务的，虚拟地址到物理地址就是依靠物理地址来完成的，  
3、页表就是提供虚拟页到物理页转化的数据结构，我们进程分配虚拟页之后，是一定要在进程当中找一个对应的物理页来进行一个映射的，一个进程产生了一个新的虚拟页，我们需要一个物理页来对它进行绑定，因此我们需要有探测内存中的空闲物理页帧的机制。  
3、我们的页表可以看成是一个一个数组，然后这个数组里面存的结构就叫做页表项，然后我们地址映射靠的就是解析页表项，然后这就要求我们能够知道这个页表项的物理地址的话，就需要能够直接访问到它，就需要这个接口。  
*/
1、实验目的为：进程创建时，为每一个进程分配一张页表（实际上还有更高级的抽象：地址空间和逻辑段，但是都是以页表结构为核心），能够在页表中实现为进程分配新的虚拟页以及释放任意虚拟页的功能。  
2、进程的页表均在内核空间中，为了能够给新进程分配页表，需要提供分配页表的策略。  
3、为了每个进程都能够自由的分配和回收自身任意虚拟页，需要有探测内存中的空闲物理页帧以及回收任意物理页帧的机制，并且必须有访问和修改随机页表项的接口。

## 基本设计
1、rcore tutorial采用双页表的设计，即内核使用单独的地址空间，不同的用户进程在用户态时使用各自的用户地址空间，这也就意味着地址空间的切换发生在特权级切换时。  
/*
进程之间的切换页表的时候实际上是这样一个过程：先从我们的a进程进入到我们的内核态下，这个时候会发生一次地址空间的切换，然后在这个时候我们在内核空间里面把b进程地址空间相关的上下文放到TrapContext里面去，然后我们在进行一个恢复，就从内核的地址空间又切换到了b的地址空间。
*/

2、内核空间采用对等映射（恒等映射）的方式，即内核的任意PageNum号虚拟页对应的物理页框号也是PageNum，这样的话，在内核中访问物理页时便不再会受到MMU的影响。内核页表在操作系统初始化的时候便一并完成对等映射的初始化了。  
/*
比如说1086号的虚拟页对应的也是1086的物理页帧，这样做的好处是：在内核里，我们经常要去访问不同的地址空间，然后我们可以读它的页表，我们知道它的虚拟页对应的物理页在哪里，但是我们的映射机制一旦打开就不能再关闭了，那我们的内核想要非常方便的去访问一个物理页该怎么办呢，我们就要使用对等映射的方式，也就是说，实际上我们想要访问1086号的物理页我们只需要内核的1086号虚拟页就可以了。
*/

3、每个用户进程在初始化时，同步为其分配一个物理页作为其页表的根节点，也就是最高级的一个页表，然后，我们在给它增加页表项的时候在进行进一步的处理，此后，所有的操作均在该页表上实现。  
/*
我们进程页表进来的时候当然只有一个新的，然后分配它的虚拟页，然后它的页表才能逐渐的增加页表项。
*/

4、chapter4的核心内容在于对页表的支持，这里的页表被封装成了一个PageTable的数据结构，这个结构实际上控制了所有被该页表占用的页框，需要实现的接口包括：
    1）创建一个新的页表  
    2）进程分配或回收一个虚拟页时，需要去修改对应的页表项，因此，页表必须能够随机访问和修改页表项。  
    3）为了满足1)、2）的要求，必须能探测和分配空闲物理页帧以及回收物理页帧。  
/*
随机访问和修改页表项:我们是用虚拟页号去访问页表项的，这是个三级页表结构，它如果想要去访问对应的页表项的话，他可能需要经过三次映射才能够找到，但是我们在设计这个页表的时候，我们实际实现的时候是通过三级页表去找到页表项，但是我们必须做好一个封装，我们这里面的细节给隐藏起来，也就是说我们必须设计直接通过一个虚拟页号就可以找到那个页表项，我们必须找到这个接口，这样的话就好像直接经过一次映射就找到了，三次映射的细节被我们封装在了接口里面。  
也就是说，这个接口一旦实现了，我们就可以直接通过虚拟页去找到对应的那个物理页所对应的那个页表项，而不用每次都去做这个三次映射处理。
*/
## 注意
本次实验采用三级页表结构，所以任意一个虚拟页的访问和处理必须经过三次查表：先通过一级页号去访问根页表对应的页表项，获取对应的二级页表的地址，在通过二级页号去访问对应二级页表中的页表项，从中取出三级页表的地址，在通过三级页号去访问对应页表项，从中获取地址对应的物理页帧。


# 实验过程
## 1、构建页表相关的数据结构和方法
### 建立页与地址之间的转换关系
    // os/src/mm/address.rs

    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
    pub struct PhysAddr(pub usize);

    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
    pub struct VirtAddr(pub usize);

    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
    pub struct PhysPageNum(pub usize);

    #[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
    pub struct VirtPageNum(pub usize);
/*
页表是让我们虚拟页和物理页之间做转换，但是我们实际上去访问数据的时候是通过虚拟地址和物理地址，虚拟地址是我们给出来的，物理地址是实际上去内存当中访问的那个地址，所以我们需要一些基本的结构，并且做了一些封装。其实这些结构都是简单的包裹了一个usize结构，主要是为了更好的增加类型方法，来进行类型装换。
*/

// os/src/mm/address.rs

impl PhysAddr {
    pub fn page_offset(&self) -> usize { self.0 & (PAGE_SIZE - 1) }
}

impl From<PhysAddr> for PhysPageNum {
    fn from(v: PhysAddr) -> Self {
        assert_eq!(v.page_offset(), 0);
        v.floor()
    }
}

impl From<PhysPageNum> for PhysAddr {
    fn from(v: PhysPageNum) -> Self { Self(v.0 << PAGE_SIZE_BITS) }
}
/*
我们这里是用来from triat里面的from来对它们进行处理，，通过这个处理之后我们就可以usize到物理页，到虚拟页、到物理地址、到虚拟地址都可以通过from函数轻易的实现了。
*/  
这里增加了各种结构与usize的from关系，通过这样的方式我们可以用较为简单和通用的写法去获取结构包裹的usize值。
/*
比方说，我们想要一个虚拟页vp，我们有了一个usize，我们应该怎么做呢，我们通过这样一个from调用：let vp = VirtPageNum::from(p);，然后就可以封装好一个VirtPageNum，如果我们想要获取里面的，我们vp.into就可以了。我们当然也可以使用vp.0。
*/
let p:usize = 1086;
let vp = VirtPageNum::from(p);
let p2:usize = vp.into;

/*
之前，我们封装的是usize与虚拟页、usize与虚拟地址、usize与物理页、usize与物理地址之间的关系，但是实际上，我们更重要的关系是虚拟地址跟虚拟页之间的关系，物理地址跟物理页之间的关系。我们可以想一下，一个地址如果是分成一个页一个页的，那它一定有自己所在的那个页，我们的虚拟地址所在的虚拟页，那怎么转换成虚拟页，就是调用floor(&self) -> VirtPageNum函数，ceil(&self) -> VirtPageNum函数的功能是：比方说某一个地址在第五页上面，那ceil（）函数会到它后面那个页里面，到第六页，它永远是取到了地址的后面一个页，但是有一种特殊情况，就是当它是某一页的第一个位置，也就是边界的那个位置的话，ceil()函数和floor()函数是一样的，都表示当前的页。  
我们这样设计的原因是，到后面我们会用到很多区间设计，就是一个页的区间以及一个地址的区间都是一个左闭右开的结构，这样的话更方便它的一个处理。  
总之floor()和ceil()都是把虚拟地址转化成虚拟页。  

page_offset(&self) -> usize功能是：页中有一个业内偏移page_offset，会提供它的偏移；然后aligned(&self) -> bool是一个判断函数，表示它的偏移量是不是刚好为0，也就是说判断是不是我们刚才说的在某一个页的首元素；然后就是一个转化。  
物理页和虚拟页也是一样。  

还有一个我们前面说了，就是页号是分成一级页号，二级页号，三级页号，然后虚拟页实际上被分成了27位，然后前9位是一级页号，中间9位是二级页号，最后9位是三级页号，然后我们希望能够很简单的把它给分别获取到，这样的话有利于我们后面去访问三个页表，这样的话在虚拟页的页号结构VirtPageNum里面就有一个indexes(&self) -> [usize;3]方法，然后返回一个三维数组，然后然后里面分别存放一级页号，二级页号，三级页号。
*/  

/*
我们后面经常会虚拟页空间还是连续的，为了方便的表示一段连续的虚拟页并方便对它的处理，我们做了一些新的定义：

*/  
