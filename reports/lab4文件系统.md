# 实验目的
在之前的实验里，我们所有的数据、程序的访问都是内存当中，包括我们的每一个应用，我们如果想要执行它，都是先把数据硬编码到我们的一个操作系统的数据段里面去，然后当我们需要的时候我们去数据段里将它们取出来放到代码段中程序执行的位置去执行。显然当我们的应用非常多、非常大的时候，这种做法会让我们的内核的负担增大，所以我们希望像真实的操作系统一样有一个文件系统，我们的这些设备存放在外存当中，在需要的时候将它从外存里面读到内存里面来执行。  
实现了一个简单文件系统'easy-fs'，能够对持久储存设备I/O资源进行管理，具体来说就是：  
一：以文件为单位来组织磁盘（虚拟磁盘，是指持久储存设备）中的一系列数据信息  
二：以文件名来访问文件，并且能够根据文件地址来访问对应的数据。  
具体来说就是根据文件的路径path找到对应的文件，假设我们这个文件非常大，在用户看来是连续的，但是我们的操作系统把它存放在磁盘上的时候，它不一定能够找到连续的那么大的空间来存放，这个时候操作系统需要在磁盘上进行离散式的存放，而我们需要一种机制能够帮助我们从这个文件地址找到磁盘上对应的数据。例如这个文件是一个非常长的视频，我们要找到第32秒的那帧画面，第32秒就是文件地址，通过第32秒找到磁盘上的位置，在找到那帧画面就是对应的数据。  

# 实验过程分析：
因为文件系统是面向对象的，所以本次实验采用了自上而下的分析方法，即先考虑分析需要哪些功能，在考虑为了支撑这些功能需要哪些底层的支持，直到完成整体设计。
## 一：需要提供的系统调用
文件调用系统我们需要对外提供的系统调用接口为以下3种：
sys-open接口的功能是：根据文件名找到对应的文件，并且将该文件的访问权限交给进程，并且用返回的整数文件描述符作为它的访问标志；参数是路径path和flags；返回值是该文件的文件描述符。  
在正常的操作系统中，会有目录套目录的形式出现，但是在这次实验中，只有一个根目录。  
sys_reade和sys_write接口的功能分别是：进程通过打开文件时得到的文件描述符fd将文件写或者读到用户的buf数组中（涉及到地址映射）；参数为fd,缓冲区buf数组,读写长度len，如果读写长度不够就尽可能的进行读写，即当文件的字节多于缓冲区的字节时，只会读取缓冲区长度的字节；返回值是实际读写长度。    
sys-close功能为关闭进程对文件描述符为fd的文件的访问权限。  

## 二：磁盘、操作系统和进程对文件的读写访问的结构和方法。  
### 主要设计思路
   我们假设在磁盘中存放着一种结构DiskInode,我们只需要找到这个结构并且把它读入内存来分析，就可以获取这个文件的全部信息，并且可以通过随机访问的方式去访问文件的任意一个位置的内容。DiskInode被组织在外存中的一块叫DiskInode表的外存区域中，通过编号就可以唯一访问到。  
    如果我们有了DiskInide,sys_read和sys_write就都可以实现了，因为我们假设找到DiskInide就可以随机访问，DiskInide一个一个的放在外存的DiskInide表当中，所以每一个DiskInide都会有一个索引，所以我们根据这个索引就可以找到对应的DiskInide，DiskInide表相当于一个小缓存池，当我们需要的时候从里面找一个没有被分配的位置把它分配给DiskInide来用，用完了之后我们就利用标志位把它给释放掉。  
   DiskInode被存放在磁盘上，我们访问它就需要先把它放入内存中，DiskInode在内存中的结构我们称为inode，通过inode我们可以访问到其对应的DiskInode。因此进程想要获得对文件的访问能力就是要找到文件对应的inode,如果文件的DiskInode还没有被放入内存中，我们需要先将其处理一下变成inode，然后把inode缓存到内存中；如果文件的DiskInode已经被放入内存中，我们只需要直接返回其缓存在内存中的inode即可。  
   外存的结构是文件的一个固有属性，但是当我们把它拿到内存当中之后，我们还需要给它添加一些固有属性之外的别的属性，因为拿到内存当中是给程序用的。  
   因为一个DiskInide代表一个文件，并且访问一个文件的进程可能有多个，所以可能有多个进程访问同一个DiskInode,而对应的Inode只有一个，所以在C语言实现中我们需要给inode添加引用计数，但是在rust中我们只需要让Inode使用rust的Arc封装就可以很好的利用这个智能指针的特性。rust中编译器会自动实现引用计数加一，引用计数减一，释放inode等操作。  
   而每一个进程对文件访问时，都会有一些区别于其他进程的具体特征（例如进程的访问权限，进程当前的读写位置等），所以具体到进程我们同样需要建立一个结构OSInode给每一个进程使用。记录每个进程使用文件的特性，例如当前进程读到哪里了，方便进程切换之后能够继续此进程。  
### 代码的实现：
   我们需要找到DiskInide就能够随机读写文件当中的数据。所以实现DiskInide结构需要read_at和write_at函数，这两个函数的功能分别是读写文件。  
   设计Inode结构的目的是进程通过Inode来读写外存，所以实现Inode结构需要read_disk_inode和modify_disk_inode函数，这两个函数可以直接通过Inode对其对应的DiskInide并获取其返回值，例如read_at()和write_at()，利用这个方法我们可以实现利用Inode读写函数。这两个函数的参数分别是&self和闭包f，闭包f可以理解为一个函数，闭包里面传入DiskInide的引用，返回一个V，f可以取具体的函数。modify的闭包的参数需要可以修改。DiskInide可以read_at和write_at，所以Inode必须继承DiskInide的方法，参数offset表示读写的时候起始点的文件地址，参数buf有一个自己的长度，在Inode结构中read_at函数中，闭包disk_inode.read_at的结果作为read_disk_inode的结果作为read_at的结果。  
   OSInode的结构非常显然，有readable,writeable,inner里面是offset,inode；包含读写权限，起始地址offset以及inode指针，在读写函数的时候我们并没有给出文件的起点，实际上这个起点由各进程对应的OSInode的offset给出。OSInode结构需要read()和write()，read()需要从Inode里面取read_at,读完之后offset还需要加上读的长度。
   显然，在这个过程中实现了访问其内部对应的Inode，至此，只要获取了进程文件所对应的OSInode，我们就可以对文件进行读写操作了。而在进程的syscall中，我们查找OSInode的依据是一个自然数fd,这是因为我们为每一个进程维护一个OSInode表，fd对应的是OSInode在这个表中的索引，这个表位于进程控制块TCB中。我们用户用的是底层封装好的东西，这样层层封装对我们的逻辑有很大的帮助。  
   至此，我们就可以实现sys_read和sys_write了。  
   
## 三：通过文件名获取对文件的访问能力  
   我们实现了只要获取了进程文件所对应的OSInode，我们就可以对文件进行读写操作了，但是文件系统需要的是给了一个文件名我们就需要能够访问到对应的数据，所以我们就需要根据一个文件名来造出来一个OSInode给进程来用。  
   根据上述描述，我们知道，只要我们把文件的DiskInide最终转化为OSInode并存放在进程的fd_table中，并获取其id，就可以实现对文件数据的随机访问了，而open()操作实际上就是实现这个过程。  
### 目录与目录项
   想要实现open（）的功能，我们就必须要获取文件对应的DiskInide编号。因为获取了DiskInide编号我们就能找到对应的DiskInide，找到了DiskInide我们就能够封装一个Inode结构出来，有了这个Inode我们就能封装一个OSInode结构，然后有了这个OSInode结构放到表里面去，任务就完成。
   这里我们设计了一个特殊的结构：目录项DirEntry，这个结构包含一个文件名name和一个对应的索引号inode_number，因此我们只需要找到name为给定名称的DerEntry就可以了。然而，文件系统中的DerEntry可能有很多，而且需要可持久化的存储，我们不可能把DerEntry放在内存中，因此，我们把这些DerEntry也放在了一个文件中，并且将这个文件的DiskInide放在DiskInide表的0号位置，这个用来放置DerEntry的文件叫做目录，在我们的实验中只有一个目录文件，即根目录文件，它的DiskInide编号为0号，我们随时都可以访问到它。而通过遍历这个文件，我们就可以找到name为我们需要的名称的对应的DerEntry了。  
   DerEntry结构包含的方法有：as_bytes（）和as_bytes_mut（）访问并修改它们；name(),inode_number()。
   至此，我们可以为Inode结构提供检索对应文件名的Inode编号的方法。在Inode结构里面进行这项操作的原因是根目录的DiskInode的编号是固定的0号，find_inode_id()功能是从根目录里面找到name对应的目录项，参数是&self,name,disk_inode;实现方法是遍历了根目录里面的所有目录项，如果目录项的名字等于传入的参数name，那么我们就返回这个目录项的编号。函数find（）功能：返回Inode;参数是&self,name,&str；要返回一个Inode形式，实现是将self对应的disk_inode放进去，然后通过find_inode_id(name,disk_inode)获取一个对应的编号。  
   通过在根目录下调用find()方法，我们就可以获取到对应文件的一个Inode了，而根目录的编号已知为0，因此可以很简单的访问到。
   
## 四：文件系统的磁盘访问接口
   在之前我们都是假设能够随机访问磁盘，在这一节我们就要解决如何利用DiskInode去访问文件信息的问题。
### 块设备接口层
   一个文件系统对应一个虚拟设备，而我们对磁盘的访问是以Block为基本单位的，我们通过块的编号去读写整个磁盘块，我们通过虚拟化来实现对磁盘的这种访问模式，其具体细节在easy_fs_fuse中，我们利用一个Linux文件来模拟磁盘区域，但是现在我们只需要关注虚拟化为我们提供的接口即可：在BlockDevice结构中函数read_block(&self,block_id:usize,buf:&mut[u8])功能是根据block_id把一个我们规定为4096bit大小的磁盘块数据读到buf数组里面去，writeck(&self,block_id:usize,buf:[u8])功能是把buf中的数据写入block_id号磁盘块中。因此，我们只要有block_id我们就可以直接找到对应的block，然后把它读写，与buf进行数据交换。
### 块缓存层
   访问磁盘块时，我们有必要把最近访问的磁盘块在内存中缓存起来来减少I/O操作，从而提高系统性能。
